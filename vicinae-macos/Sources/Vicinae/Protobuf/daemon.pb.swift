// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: daemon.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Proto_Ext_Daemon_UrlResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// empty string if no error
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_UrlRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_PingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_PingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_DmenuRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawContent: String = String()

  public var navigationTitle: String = String()

  public var placeholder: String = String()

  public var sectionTitle: String = String()

  public var noSection: Bool = false

  public var noQuickLook: Bool = false

  public var noIcon: Bool = false

  public var noMetadata: Bool = false

  public var query: String = String()

  public var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  public var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  public mutating func clearWidth() {self._width = nil}

  public var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  public var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  public mutating func clearHeight() {self._height = nil}

  public var noFooter: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _width: Int32? = nil
  fileprivate var _height: Int32? = nil
}

public struct Proto_Ext_Daemon_LaunchAppRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appID: String = String()

  public var args: [String] = []

  public var newInstance: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_LaunchAppResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: String = String()

  public var focusedWindowTitle: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_ListAppsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var withActions: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_AppInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var hidden: Bool = false

  public var path: String = String()

  public var description_p: String = String()

  public var program: String = String()

  public var isTerminalApp: Bool = false

  public var keywords: [String] = []

  public var iconURL: String = String()

  public var isAction: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_ListAppsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var apps: [Proto_Ext_Daemon_AppInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_DmenuResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var output: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Daemon_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Daemon_Request.OneOf_Payload? = nil

  public var ping: Proto_Ext_Daemon_PingRequest {
    get {
      if case .ping(let v)? = payload {return v}
      return Proto_Ext_Daemon_PingRequest()
    }
    set {payload = .ping(newValue)}
  }

  public var url: Proto_Ext_Daemon_UrlRequest {
    get {
      if case .url(let v)? = payload {return v}
      return Proto_Ext_Daemon_UrlRequest()
    }
    set {payload = .url(newValue)}
  }

  public var dmenu: Proto_Ext_Daemon_DmenuRequest {
    get {
      if case .dmenu(let v)? = payload {return v}
      return Proto_Ext_Daemon_DmenuRequest()
    }
    set {payload = .dmenu(newValue)}
  }

  public var launchApp: Proto_Ext_Daemon_LaunchAppRequest {
    get {
      if case .launchApp(let v)? = payload {return v}
      return Proto_Ext_Daemon_LaunchAppRequest()
    }
    set {payload = .launchApp(newValue)}
  }

  public var listApps: Proto_Ext_Daemon_ListAppsRequest {
    get {
      if case .listApps(let v)? = payload {return v}
      return Proto_Ext_Daemon_ListAppsRequest()
    }
    set {payload = .listApps(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case ping(Proto_Ext_Daemon_PingRequest)
    case url(Proto_Ext_Daemon_UrlRequest)
    case dmenu(Proto_Ext_Daemon_DmenuRequest)
    case launchApp(Proto_Ext_Daemon_LaunchAppRequest)
    case listApps(Proto_Ext_Daemon_ListAppsRequest)

  }

  public init() {}
}

public struct Proto_Ext_Daemon_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Daemon_Response.OneOf_Payload? = nil

  public var ping: Proto_Ext_Daemon_PingResponse {
    get {
      if case .ping(let v)? = payload {return v}
      return Proto_Ext_Daemon_PingResponse()
    }
    set {payload = .ping(newValue)}
  }

  public var url: Proto_Ext_Daemon_UrlResponse {
    get {
      if case .url(let v)? = payload {return v}
      return Proto_Ext_Daemon_UrlResponse()
    }
    set {payload = .url(newValue)}
  }

  public var dmenu: Proto_Ext_Daemon_DmenuResponse {
    get {
      if case .dmenu(let v)? = payload {return v}
      return Proto_Ext_Daemon_DmenuResponse()
    }
    set {payload = .dmenu(newValue)}
  }

  public var launchApp: Proto_Ext_Daemon_LaunchAppResponse {
    get {
      if case .launchApp(let v)? = payload {return v}
      return Proto_Ext_Daemon_LaunchAppResponse()
    }
    set {payload = .launchApp(newValue)}
  }

  public var listApps: Proto_Ext_Daemon_ListAppsResponse {
    get {
      if case .listApps(let v)? = payload {return v}
      return Proto_Ext_Daemon_ListAppsResponse()
    }
    set {payload = .listApps(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case ping(Proto_Ext_Daemon_PingResponse)
    case url(Proto_Ext_Daemon_UrlResponse)
    case dmenu(Proto_Ext_Daemon_DmenuResponse)
    case launchApp(Proto_Ext_Daemon_LaunchAppResponse)
    case listApps(Proto_Ext_Daemon_ListAppsResponse)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.ext.daemon"

extension Proto_Ext_Daemon_UrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UrlResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_UrlResponse, rhs: Proto_Ext_Daemon_UrlResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_UrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UrlRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_UrlRequest, rhs: Proto_Ext_Daemon_UrlRequest) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_PingRequest, rhs: Proto_Ext_Daemon_PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_PingResponse, rhs: Proto_Ext_Daemon_PingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_DmenuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DmenuRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}raw_content\0\u{3}navigation_title\0\u{1}placeholder\0\u{3}section_title\0\u{3}no_section\0\u{3}no_quick_look\0\u{3}no_icon\0\u{3}no_metadata\0\u{1}query\0\u{1}width\0\u{1}height\0\u{3}no_footer\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rawContent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.navigationTitle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.placeholder) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sectionTitle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.noSection) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.noQuickLook) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.noIcon) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.noMetadata) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.noFooter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawContent.isEmpty {
      try visitor.visitSingularStringField(value: self.rawContent, fieldNumber: 1)
    }
    if !self.navigationTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.navigationTitle, fieldNumber: 2)
    }
    if !self.placeholder.isEmpty {
      try visitor.visitSingularStringField(value: self.placeholder, fieldNumber: 3)
    }
    if !self.sectionTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.sectionTitle, fieldNumber: 4)
    }
    if self.noSection != false {
      try visitor.visitSingularBoolField(value: self.noSection, fieldNumber: 5)
    }
    if self.noQuickLook != false {
      try visitor.visitSingularBoolField(value: self.noQuickLook, fieldNumber: 6)
    }
    if self.noIcon != false {
      try visitor.visitSingularBoolField(value: self.noIcon, fieldNumber: 7)
    }
    if self.noMetadata != false {
      try visitor.visitSingularBoolField(value: self.noMetadata, fieldNumber: 8)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 9)
    }
    try { if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    if self.noFooter != false {
      try visitor.visitSingularBoolField(value: self.noFooter, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_DmenuRequest, rhs: Proto_Ext_Daemon_DmenuRequest) -> Bool {
    if lhs.rawContent != rhs.rawContent {return false}
    if lhs.navigationTitle != rhs.navigationTitle {return false}
    if lhs.placeholder != rhs.placeholder {return false}
    if lhs.sectionTitle != rhs.sectionTitle {return false}
    if lhs.noSection != rhs.noSection {return false}
    if lhs.noQuickLook != rhs.noQuickLook {return false}
    if lhs.noIcon != rhs.noIcon {return false}
    if lhs.noMetadata != rhs.noMetadata {return false}
    if lhs.query != rhs.query {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs.noFooter != rhs.noFooter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_LaunchAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchAppRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}app_id\0\u{1}args\0\u{3}new_instance\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.newInstance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 2)
    }
    if self.newInstance != false {
      try visitor.visitSingularBoolField(value: self.newInstance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_LaunchAppRequest, rhs: Proto_Ext_Daemon_LaunchAppRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.args != rhs.args {return false}
    if lhs.newInstance != rhs.newInstance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_LaunchAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchAppResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}error\0\u{3}focused_window_title\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedWindowTitle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    if !self.focusedWindowTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedWindowTitle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_LaunchAppResponse, rhs: Proto_Ext_Daemon_LaunchAppResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.focusedWindowTitle != rhs.focusedWindowTitle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_ListAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAppsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}with_actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withActions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withActions != false {
      try visitor.visitSingularBoolField(value: self.withActions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_ListAppsRequest, rhs: Proto_Ext_Daemon_ListAppsRequest) -> Bool {
    if lhs.withActions != rhs.withActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_AppInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}hidden\0\u{1}path\0\u{1}description\0\u{1}program\0\u{3}is_terminal_app\0\u{1}keywords\0\u{3}icon_url\0\u{3}is_action\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.program) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isTerminalApp) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.keywords) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.program.isEmpty {
      try visitor.visitSingularStringField(value: self.program, fieldNumber: 6)
    }
    if self.isTerminalApp != false {
      try visitor.visitSingularBoolField(value: self.isTerminalApp, fieldNumber: 7)
    }
    if !self.keywords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keywords, fieldNumber: 8)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 9)
    }
    if self.isAction != false {
      try visitor.visitSingularBoolField(value: self.isAction, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_AppInfo, rhs: Proto_Ext_Daemon_AppInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.path != rhs.path {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.program != rhs.program {return false}
    if lhs.isTerminalApp != rhs.isTerminalApp {return false}
    if lhs.keywords != rhs.keywords {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.isAction != rhs.isAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_ListAppsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAppsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}apps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_ListAppsResponse, rhs: Proto_Ext_Daemon_ListAppsResponse) -> Bool {
    if lhs.apps != rhs.apps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_DmenuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DmenuResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}output\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.output) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.output.isEmpty {
      try visitor.visitSingularStringField(value: self.output, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_DmenuResponse, rhs: Proto_Ext_Daemon_DmenuResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ping\0\u{1}url\0\u{1}dmenu\0\u{3}launch_app\0\u{3}list_apps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Daemon_PingRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Daemon_UrlRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .url(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .url(v)
        }
      }()
      case 3: try {
        var v: Proto_Ext_Daemon_DmenuRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dmenu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dmenu(v)
        }
      }()
      case 4: try {
        var v: Proto_Ext_Daemon_LaunchAppRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .launchApp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .launchApp(v)
        }
      }()
      case 5: try {
        var v: Proto_Ext_Daemon_ListAppsRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listApps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listApps(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .url?: try {
      guard case .url(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .dmenu?: try {
      guard case .dmenu(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .launchApp?: try {
      guard case .launchApp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .listApps?: try {
      guard case .listApps(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_Request, rhs: Proto_Ext_Daemon_Request) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Daemon_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ping\0\u{1}url\0\u{1}dmenu\0\u{3}launch_app\0\u{3}list_apps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Daemon_PingResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Daemon_UrlResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .url(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .url(v)
        }
      }()
      case 3: try {
        var v: Proto_Ext_Daemon_DmenuResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dmenu(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dmenu(v)
        }
      }()
      case 4: try {
        var v: Proto_Ext_Daemon_LaunchAppResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .launchApp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .launchApp(v)
        }
      }()
      case 5: try {
        var v: Proto_Ext_Daemon_ListAppsResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listApps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listApps(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .url?: try {
      guard case .url(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .dmenu?: try {
      guard case .dmenu(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .launchApp?: try {
      guard case .launchApp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .listApps?: try {
      guard case .listApps(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Daemon_Response, rhs: Proto_Ext_Daemon_Response) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
