// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: manager.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proto_Ext_Manager_CommandMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case view // = 0
  case noView // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .view
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .view
    case 1: self = .noView
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .view: return 0
    case .noView: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Manager_CommandMode] = [
    .view,
    .noView,
  ]

}

public enum Proto_Ext_Manager_CommandEnv: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case development // = 0
  case production // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .development
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .development
    case 1: self = .production
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .development: return 0
    case .production: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Manager_CommandEnv] = [
    .development,
    .production,
  ]

}

public struct Proto_Ext_Manager_RequestData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Proto_Ext_Manager_RequestData.OneOf_Data? = nil

  public var ping: Proto_Ext_Manager_ManagerPingRequestData {
    get {
      if case .ping(let v)? = data {return v}
      return Proto_Ext_Manager_ManagerPingRequestData()
    }
    set {data = .ping(newValue)}
  }

  public var load: Proto_Ext_Manager_ManagerLoadCommand {
    get {
      if case .load(let v)? = data {return v}
      return Proto_Ext_Manager_ManagerLoadCommand()
    }
    set {data = .load(newValue)}
  }

  public var unload: Proto_Ext_Manager_ManagerUnloadCommand {
    get {
      if case .unload(let v)? = data {return v}
      return Proto_Ext_Manager_ManagerUnloadCommand()
    }
    set {data = .unload(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case ping(Proto_Ext_Manager_ManagerPingRequestData)
    case load(Proto_Ext_Manager_ManagerLoadCommand)
    case unload(Proto_Ext_Manager_ManagerUnloadCommand)

  }

  public init() {}
}

public struct Proto_Ext_Manager_ManagerPingRequestData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Manager_ResponseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Proto_Ext_Manager_ResponseData.OneOf_Data? = nil

  public var ack: Proto_Ext_Common_AckResponse {
    get {
      if case .ack(let v)? = data {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {data = .ack(newValue)}
  }

  public var load: Proto_Ext_Manager_ManagerLoadResponseData {
    get {
      if case .load(let v)? = data {return v}
      return Proto_Ext_Manager_ManagerLoadResponseData()
    }
    set {data = .load(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case ack(Proto_Ext_Common_AckResponse)
    case load(Proto_Ext_Manager_ManagerLoadResponseData)

  }

  public init() {}
}

public struct Proto_Ext_Manager_ManagerLoadCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Proto_Ext_Manager_CommandMode = .view

  public var env: Proto_Ext_Manager_CommandEnv = .development

  public var vicinaePath: String = String()

  /// javascript source file to execute
  public var entrypoint: String = String()

  public var preferenceValues: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  public var argumentValues: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  public var isRaycast: Bool = false

  public var commandName: String = String()

  public var extensionID: String = String()

  public var extensionName: String = String()

  public var ownerOrAuthorName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Manager_ManagerUnloadCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Manager_ManagerLoadResponseData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.ext.manager"

extension Proto_Ext_Manager_CommandMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0View\0\u{1}NoView\0")
}

extension Proto_Ext_Manager_CommandEnv: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Development\0\u{1}Production\0")
}

extension Proto_Ext_Manager_RequestData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ping\0\u{1}load\0\u{1}unload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Manager_ManagerPingRequestData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ping(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Manager_ManagerLoadCommand?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .load(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .load(v)
        }
      }()
      case 3: try {
        var v: Proto_Ext_Manager_ManagerUnloadCommand?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .unload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .unload(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .ping?: try {
      guard case .ping(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .load?: try {
      guard case .load(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unload?: try {
      guard case .unload(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_RequestData, rhs: Proto_Ext_Manager_RequestData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Manager_ManagerPingRequestData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerPingRequestData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_ManagerPingRequestData, rhs: Proto_Ext_Manager_ManagerPingRequestData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Manager_ResponseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ack\0\u{1}load\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ack(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Manager_ManagerLoadResponseData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .load(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .load(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .ack?: try {
      guard case .ack(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .load?: try {
      guard case .load(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_ResponseData, rhs: Proto_Ext_Manager_ResponseData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Manager_ManagerLoadCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoadCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mode\0\u{1}env\0\u{3}vicinae_path\0\u{1}entrypoint\0\u{3}preference_values\0\u{3}argument_values\0\u{3}is_raycast\0\u{3}command_name\0\u{3}extension_id\0\u{3}extension_name\0\u{3}owner_or_author_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.env) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.vicinaePath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.entrypoint) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.preferenceValues) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.argumentValues) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isRaycast) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.commandName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.extensionID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.extensionName) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.ownerOrAuthorName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .view {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.env != .development {
      try visitor.visitSingularEnumField(value: self.env, fieldNumber: 2)
    }
    if !self.vicinaePath.isEmpty {
      try visitor.visitSingularStringField(value: self.vicinaePath, fieldNumber: 3)
    }
    if !self.entrypoint.isEmpty {
      try visitor.visitSingularStringField(value: self.entrypoint, fieldNumber: 4)
    }
    if !self.preferenceValues.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.preferenceValues, fieldNumber: 5)
    }
    if !self.argumentValues.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.argumentValues, fieldNumber: 6)
    }
    if self.isRaycast != false {
      try visitor.visitSingularBoolField(value: self.isRaycast, fieldNumber: 7)
    }
    if !self.commandName.isEmpty {
      try visitor.visitSingularStringField(value: self.commandName, fieldNumber: 8)
    }
    if !self.extensionID.isEmpty {
      try visitor.visitSingularStringField(value: self.extensionID, fieldNumber: 9)
    }
    if !self.extensionName.isEmpty {
      try visitor.visitSingularStringField(value: self.extensionName, fieldNumber: 10)
    }
    if !self.ownerOrAuthorName.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerOrAuthorName, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_ManagerLoadCommand, rhs: Proto_Ext_Manager_ManagerLoadCommand) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.env != rhs.env {return false}
    if lhs.vicinaePath != rhs.vicinaePath {return false}
    if lhs.entrypoint != rhs.entrypoint {return false}
    if lhs.preferenceValues != rhs.preferenceValues {return false}
    if lhs.argumentValues != rhs.argumentValues {return false}
    if lhs.isRaycast != rhs.isRaycast {return false}
    if lhs.commandName != rhs.commandName {return false}
    if lhs.extensionID != rhs.extensionID {return false}
    if lhs.extensionName != rhs.extensionName {return false}
    if lhs.ownerOrAuthorName != rhs.ownerOrAuthorName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Manager_ManagerUnloadCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerUnloadCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_ManagerUnloadCommand, rhs: Proto_Ext_Manager_ManagerUnloadCommand) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Manager_ManagerLoadResponseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoadResponseData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Manager_ManagerLoadResponseData, rhs: Proto_Ext_Manager_ManagerLoadResponseData) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
