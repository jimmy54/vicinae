// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ui.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proto_Ext_Ui_ToastStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case success // = 0
  case info // = 1
  case warning // = 2
  case error // = 3
  case dynamic // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .info
    case 2: self = .warning
    case 3: self = .error
    case 4: self = .dynamic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .info: return 1
    case .warning: return 2
    case .error: return 3
    case .dynamic: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Ui_ToastStyle] = [
    .success,
    .info,
    .warning,
    .error,
    .dynamic,
  ]

}

public enum Proto_Ext_Ui_PopToRootType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case popToRootDefault // = 0
  case popToRootImmediate // = 1
  case popToRootSuspended // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .popToRootDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .popToRootDefault
    case 1: self = .popToRootImmediate
    case 2: self = .popToRootSuspended
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .popToRootDefault: return 0
    case .popToRootImmediate: return 1
    case .popToRootSuspended: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Ui_PopToRootType] = [
    .popToRootDefault,
    .popToRootImmediate,
    .popToRootSuspended,
  ]

}

public enum Proto_Ext_Ui_ConfirmAlertActionStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case `default` // = 0
  case destructive // = 1
  case cancel // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .destructive
    case 2: self = .cancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .destructive: return 1
    case .cancel: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Ui_ConfirmAlertActionStyle] = [
    .default,
    .destructive,
    .cancel,
  ]

}

public enum Proto_Ext_Ui_ImageMask: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case circle // = 1
  case roundedRectangle // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .circle
    case 2: self = .roundedRectangle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .circle: return 1
    case .roundedRectangle: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_Ext_Ui_ImageMask] = [
    .none,
    .circle,
    .roundedRectangle,
  ]

}

public struct Proto_Ext_Ui_ShowToastRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var style: Proto_Ext_Ui_ToastStyle = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_HideToastRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_UpdateToastRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_PushViewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_PopViewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_CloseMainWindowRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clearRootSearch_p: Bool = false

  public var popToRoot: Proto_Ext_Ui_PopToRootType = .popToRootDefault

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ClearSearchBarRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_SetSearchTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_GetSelectedTextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_GetSelectedTextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ShowHudRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var clearRootSearch_p: Bool = false

  public var popToRoot: Proto_Ext_Ui_PopToRootType = .popToRootDefault

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_RenderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///repeated RenderNode views = 1;
  /// we will migrate to actual protobuf
  public var json: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ConfirmAlertRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var description_p: String = String()

  public var icon: Proto_Ext_Ui_Image {
    get {return _icon ?? Proto_Ext_Ui_Image()}
    set {_icon = newValue}
  }
  /// Returns true if `icon` has been explicitly set.
  public var hasIcon: Bool {return self._icon != nil}
  /// Clears the value of `icon`. Subsequent reads from it will return its default value.
  public mutating func clearIcon() {self._icon = nil}

  public var dismissAction: Proto_Ext_Ui_ConfirmAlertAction {
    get {return _dismissAction ?? Proto_Ext_Ui_ConfirmAlertAction()}
    set {_dismissAction = newValue}
  }
  /// Returns true if `dismissAction` has been explicitly set.
  public var hasDismissAction: Bool {return self._dismissAction != nil}
  /// Clears the value of `dismissAction`. Subsequent reads from it will return its default value.
  public mutating func clearDismissAction() {self._dismissAction = nil}

  public var primaryAction: Proto_Ext_Ui_ConfirmAlertAction {
    get {return _primaryAction ?? Proto_Ext_Ui_ConfirmAlertAction()}
    set {_primaryAction = newValue}
  }
  /// Returns true if `primaryAction` has been explicitly set.
  public var hasPrimaryAction: Bool {return self._primaryAction != nil}
  /// Clears the value of `primaryAction`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryAction() {self._primaryAction = nil}

  public var rememberUserChoice: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _icon: Proto_Ext_Ui_Image? = nil
  fileprivate var _dismissAction: Proto_Ext_Ui_ConfirmAlertAction? = nil
  fileprivate var _primaryAction: Proto_Ext_Ui_ConfirmAlertAction? = nil
}

public struct Proto_Ext_Ui_ConfirmAlertResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var confirmed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ConfirmAlertAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var style: Proto_Ext_Ui_ConfirmAlertActionStyle = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_PopToRootRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clearSearchBar_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Ui_Request.OneOf_Payload? = nil

  public var render: Proto_Ext_Ui_RenderRequest {
    get {
      if case .render(let v)? = payload {return v}
      return Proto_Ext_Ui_RenderRequest()
    }
    set {payload = .render(newValue)}
  }

  public var showToast: Proto_Ext_Ui_ShowToastRequest {
    get {
      if case .showToast(let v)? = payload {return v}
      return Proto_Ext_Ui_ShowToastRequest()
    }
    set {payload = .showToast(newValue)}
  }

  public var hideToast: Proto_Ext_Ui_HideToastRequest {
    get {
      if case .hideToast(let v)? = payload {return v}
      return Proto_Ext_Ui_HideToastRequest()
    }
    set {payload = .hideToast(newValue)}
  }

  public var updateToast: Proto_Ext_Ui_UpdateToastRequest {
    get {
      if case .updateToast(let v)? = payload {return v}
      return Proto_Ext_Ui_UpdateToastRequest()
    }
    set {payload = .updateToast(newValue)}
  }

  public var pushView: Proto_Ext_Ui_PushViewRequest {
    get {
      if case .pushView(let v)? = payload {return v}
      return Proto_Ext_Ui_PushViewRequest()
    }
    set {payload = .pushView(newValue)}
  }

  public var popView: Proto_Ext_Ui_PopViewRequest {
    get {
      if case .popView(let v)? = payload {return v}
      return Proto_Ext_Ui_PopViewRequest()
    }
    set {payload = .popView(newValue)}
  }

  public var clearSearch_p: Proto_Ext_Ui_ClearSearchBarRequest {
    get {
      if case .clearSearch_p(let v)? = payload {return v}
      return Proto_Ext_Ui_ClearSearchBarRequest()
    }
    set {payload = .clearSearch_p(newValue)}
  }

  public var closeMainWindow: Proto_Ext_Ui_CloseMainWindowRequest {
    get {
      if case .closeMainWindow(let v)? = payload {return v}
      return Proto_Ext_Ui_CloseMainWindowRequest()
    }
    set {payload = .closeMainWindow(newValue)}
  }

  public var showHud: Proto_Ext_Ui_ShowHudRequest {
    get {
      if case .showHud(let v)? = payload {return v}
      return Proto_Ext_Ui_ShowHudRequest()
    }
    set {payload = .showHud(newValue)}
  }

  public var setSearchText: Proto_Ext_Ui_SetSearchTextRequest {
    get {
      if case .setSearchText(let v)? = payload {return v}
      return Proto_Ext_Ui_SetSearchTextRequest()
    }
    set {payload = .setSearchText(newValue)}
  }

  public var confirmAlert: Proto_Ext_Ui_ConfirmAlertRequest {
    get {
      if case .confirmAlert(let v)? = payload {return v}
      return Proto_Ext_Ui_ConfirmAlertRequest()
    }
    set {payload = .confirmAlert(newValue)}
  }

  public var getSelectedText: Proto_Ext_Ui_GetSelectedTextRequest {
    get {
      if case .getSelectedText(let v)? = payload {return v}
      return Proto_Ext_Ui_GetSelectedTextRequest()
    }
    set {payload = .getSelectedText(newValue)}
  }

  public var popToRoot: Proto_Ext_Ui_PopToRootRequest {
    get {
      if case .popToRoot(let v)? = payload {return v}
      return Proto_Ext_Ui_PopToRootRequest()
    }
    set {payload = .popToRoot(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case render(Proto_Ext_Ui_RenderRequest)
    case showToast(Proto_Ext_Ui_ShowToastRequest)
    case hideToast(Proto_Ext_Ui_HideToastRequest)
    case updateToast(Proto_Ext_Ui_UpdateToastRequest)
    case pushView(Proto_Ext_Ui_PushViewRequest)
    case popView(Proto_Ext_Ui_PopViewRequest)
    case clearSearch_p(Proto_Ext_Ui_ClearSearchBarRequest)
    case closeMainWindow(Proto_Ext_Ui_CloseMainWindowRequest)
    case showHud(Proto_Ext_Ui_ShowHudRequest)
    case setSearchText(Proto_Ext_Ui_SetSearchTextRequest)
    case confirmAlert(Proto_Ext_Ui_ConfirmAlertRequest)
    case getSelectedText(Proto_Ext_Ui_GetSelectedTextRequest)
    case popToRoot(Proto_Ext_Ui_PopToRootRequest)

  }

  public init() {}
}

public struct Proto_Ext_Ui_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Ui_Response.OneOf_Payload? = nil

  public var render: Proto_Ext_Common_AckResponse {
    get {
      if case .render(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .render(newValue)}
  }

  public var showToast: Proto_Ext_Common_AckResponse {
    get {
      if case .showToast(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .showToast(newValue)}
  }

  public var hideToast: Proto_Ext_Common_AckResponse {
    get {
      if case .hideToast(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .hideToast(newValue)}
  }

  public var updateToast: Proto_Ext_Common_AckResponse {
    get {
      if case .updateToast(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .updateToast(newValue)}
  }

  public var pushView: Proto_Ext_Common_AckResponse {
    get {
      if case .pushView(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .pushView(newValue)}
  }

  public var popView: Proto_Ext_Common_AckResponse {
    get {
      if case .popView(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .popView(newValue)}
  }

  public var clearSearch_p: Proto_Ext_Common_AckResponse {
    get {
      if case .clearSearch_p(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .clearSearch_p(newValue)}
  }

  public var closeMainWindow: Proto_Ext_Common_AckResponse {
    get {
      if case .closeMainWindow(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .closeMainWindow(newValue)}
  }

  public var showHud: Proto_Ext_Common_AckResponse {
    get {
      if case .showHud(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .showHud(newValue)}
  }

  public var setSearchText: Proto_Ext_Common_AckResponse {
    get {
      if case .setSearchText(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .setSearchText(newValue)}
  }

  public var confirmAlert: Proto_Ext_Ui_ConfirmAlertResponse {
    get {
      if case .confirmAlert(let v)? = payload {return v}
      return Proto_Ext_Ui_ConfirmAlertResponse()
    }
    set {payload = .confirmAlert(newValue)}
  }

  public var getSelectedText: Proto_Ext_Ui_GetSelectedTextResponse {
    get {
      if case .getSelectedText(let v)? = payload {return v}
      return Proto_Ext_Ui_GetSelectedTextResponse()
    }
    set {payload = .getSelectedText(newValue)}
  }

  public var popToRoot: Proto_Ext_Common_AckResponse {
    get {
      if case .popToRoot(let v)? = payload {return v}
      return Proto_Ext_Common_AckResponse()
    }
    set {payload = .popToRoot(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case render(Proto_Ext_Common_AckResponse)
    case showToast(Proto_Ext_Common_AckResponse)
    case hideToast(Proto_Ext_Common_AckResponse)
    case updateToast(Proto_Ext_Common_AckResponse)
    case pushView(Proto_Ext_Common_AckResponse)
    case popView(Proto_Ext_Common_AckResponse)
    case clearSearch_p(Proto_Ext_Common_AckResponse)
    case closeMainWindow(Proto_Ext_Common_AckResponse)
    case showHud(Proto_Ext_Common_AckResponse)
    case setSearchText(Proto_Ext_Common_AckResponse)
    case confirmAlert(Proto_Ext_Ui_ConfirmAlertResponse)
    case getSelectedText(Proto_Ext_Ui_GetSelectedTextResponse)
    case popToRoot(Proto_Ext_Common_AckResponse)

  }

  public init() {}
}

public struct Proto_Ext_Ui_RenderNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var hasDirtyChild_p: Bool = false

  public var hasDirtyProps_p: Bool = false

  public var props: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  public var children: [Proto_Ext_Ui_RenderNode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ThemedImageSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var light: String = String()

  public var dark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Ext_Ui_ImageSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Ui_ImageSource.OneOf_Payload? = nil

  public var raw: String {
    get {
      if case .raw(let v)? = payload {return v}
      return String()
    }
    set {payload = .raw(newValue)}
  }

  public var themed: Proto_Ext_Ui_ThemedImageSource {
    get {
      if case .themed(let v)? = payload {return v}
      return Proto_Ext_Ui_ThemedImageSource()
    }
    set {payload = .themed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case raw(String)
    case themed(Proto_Ext_Ui_ThemedImageSource)

  }

  public init() {}
}

public struct Proto_Ext_Ui_DynamicColor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var light: String = String()

  public var dark: String = String()

  public var adjustContrast: Bool {
    get {return _adjustContrast ?? false}
    set {_adjustContrast = newValue}
  }
  /// Returns true if `adjustContrast` has been explicitly set.
  public var hasAdjustContrast: Bool {return self._adjustContrast != nil}
  /// Clears the value of `adjustContrast`. Subsequent reads from it will return its default value.
  public mutating func clearAdjustContrast() {self._adjustContrast = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adjustContrast: Bool? = nil
}

public struct Proto_Ext_Ui_ColorLike: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Proto_Ext_Ui_ColorLike.OneOf_Payload? = nil

  public var raw: String {
    get {
      if case .raw(let v)? = payload {return v}
      return String()
    }
    set {payload = .raw(newValue)}
  }

  public var dynamic: Proto_Ext_Ui_DynamicColor {
    get {
      if case .dynamic(let v)? = payload {return v}
      return Proto_Ext_Ui_DynamicColor()
    }
    set {payload = .dynamic(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case raw(String)
    case dynamic(Proto_Ext_Ui_DynamicColor)

  }

  public init() {}
}

public struct Proto_Ext_Ui_Image: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: Proto_Ext_Ui_ImageSource {
    get {return _source ?? Proto_Ext_Ui_ImageSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var fallback: Proto_Ext_Ui_ImageSource {
    get {return _fallback ?? Proto_Ext_Ui_ImageSource()}
    set {_fallback = newValue}
  }
  /// Returns true if `fallback` has been explicitly set.
  public var hasFallback: Bool {return self._fallback != nil}
  /// Clears the value of `fallback`. Subsequent reads from it will return its default value.
  public mutating func clearFallback() {self._fallback = nil}

  public var mask: Proto_Ext_Ui_ImageMask {
    get {return _mask ?? .none}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  public var tintColor: Proto_Ext_Ui_ColorLike {
    get {return _tintColor ?? Proto_Ext_Ui_ColorLike()}
    set {_tintColor = newValue}
  }
  /// Returns true if `tintColor` has been explicitly set.
  public var hasTintColor: Bool {return self._tintColor != nil}
  /// Clears the value of `tintColor`. Subsequent reads from it will return its default value.
  public mutating func clearTintColor() {self._tintColor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Proto_Ext_Ui_ImageSource? = nil
  fileprivate var _fallback: Proto_Ext_Ui_ImageSource? = nil
  fileprivate var _mask: Proto_Ext_Ui_ImageMask? = nil
  fileprivate var _tintColor: Proto_Ext_Ui_ColorLike? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto.ext.ui"

extension Proto_Ext_Ui_ToastStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Success\0\u{1}Info\0\u{1}Warning\0\u{1}Error\0\u{1}Dynamic\0")
}

extension Proto_Ext_Ui_PopToRootType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PopToRootDefault\0\u{1}PopToRootImmediate\0\u{1}PopToRootSuspended\0")
}

extension Proto_Ext_Ui_ConfirmAlertActionStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}Destructive\0\u{1}Cancel\0")
}

extension Proto_Ext_Ui_ImageMask: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}Circle\0\u{1}RoundedRectangle\0")
}

extension Proto_Ext_Ui_ShowToastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShowToastRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.style != .success {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ShowToastRequest, rhs: Proto_Ext_Ui_ShowToastRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_HideToastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HideToastRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_HideToastRequest, rhs: Proto_Ext_Ui_HideToastRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_UpdateToastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateToastRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_UpdateToastRequest, rhs: Proto_Ext_Ui_UpdateToastRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_PushViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushViewRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_PushViewRequest, rhs: Proto_Ext_Ui_PushViewRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_PopViewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PopViewRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_PopViewRequest, rhs: Proto_Ext_Ui_PopViewRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_CloseMainWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseMainWindowRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}clear_root_search\0\u{3}pop_to_root\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.clearRootSearch_p) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.popToRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clearRootSearch_p != false {
      try visitor.visitSingularBoolField(value: self.clearRootSearch_p, fieldNumber: 1)
    }
    if self.popToRoot != .popToRootDefault {
      try visitor.visitSingularEnumField(value: self.popToRoot, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_CloseMainWindowRequest, rhs: Proto_Ext_Ui_CloseMainWindowRequest) -> Bool {
    if lhs.clearRootSearch_p != rhs.clearRootSearch_p {return false}
    if lhs.popToRoot != rhs.popToRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ClearSearchBarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClearSearchBarRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ClearSearchBarRequest, rhs: Proto_Ext_Ui_ClearSearchBarRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_SetSearchTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSearchTextRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_SetSearchTextRequest, rhs: Proto_Ext_Ui_SetSearchTextRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_GetSelectedTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSelectedTextRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_GetSelectedTextRequest, rhs: Proto_Ext_Ui_GetSelectedTextRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_GetSelectedTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSelectedTextResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_GetSelectedTextResponse, rhs: Proto_Ext_Ui_GetSelectedTextResponse) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ShowHudRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShowHudRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}clear_root_search\0\u{3}pop_to_root\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.clearRootSearch_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.popToRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.clearRootSearch_p != false {
      try visitor.visitSingularBoolField(value: self.clearRootSearch_p, fieldNumber: 2)
    }
    if self.popToRoot != .popToRootDefault {
      try visitor.visitSingularEnumField(value: self.popToRoot, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ShowHudRequest, rhs: Proto_Ext_Ui_ShowHudRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.clearRootSearch_p != rhs.clearRootSearch_p {return false}
    if lhs.popToRoot != rhs.popToRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_RenderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}json\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_RenderRequest, rhs: Proto_Ext_Ui_RenderRequest) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ConfirmAlertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmAlertRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}description\0\u{1}icon\0\u{3}dismiss_action\0\u{3}primary_action\0\u{3}remember_user_choice\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._icon) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dismissAction) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._primaryAction) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.rememberUserChoice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._icon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dismissAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._primaryAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.rememberUserChoice != false {
      try visitor.visitSingularBoolField(value: self.rememberUserChoice, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ConfirmAlertRequest, rhs: Proto_Ext_Ui_ConfirmAlertRequest) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._icon != rhs._icon {return false}
    if lhs._dismissAction != rhs._dismissAction {return false}
    if lhs._primaryAction != rhs._primaryAction {return false}
    if lhs.rememberUserChoice != rhs.rememberUserChoice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ConfirmAlertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmAlertResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}confirmed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.confirmed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confirmed != false {
      try visitor.visitSingularBoolField(value: self.confirmed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ConfirmAlertResponse, rhs: Proto_Ext_Ui_ConfirmAlertResponse) -> Bool {
    if lhs.confirmed != rhs.confirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ConfirmAlertAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmAlertAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}style\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.style != .default {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ConfirmAlertAction, rhs: Proto_Ext_Ui_ConfirmAlertAction) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.style != rhs.style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_PopToRootRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PopToRootRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}clear_search_bar\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.clearSearchBar_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clearSearchBar_p != false {
      try visitor.visitSingularBoolField(value: self.clearSearchBar_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_PopToRootRequest, rhs: Proto_Ext_Ui_PopToRootRequest) -> Bool {
    if lhs.clearSearchBar_p != rhs.clearSearchBar_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}render\0\u{3}show_toast\0\u{3}hide_toast\0\u{3}update_toast\0\u{3}push_view\0\u{3}pop_view\0\u{3}clear_search\0\u{3}close_main_window\0\u{3}show_hud\0\u{3}set_search_text\0\u{3}confirm_alert\0\u{3}get_selected_text\0\u{3}pop_to_root\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Ui_RenderRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .render(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .render(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Ui_ShowToastRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .showToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .showToast(v)
        }
      }()
      case 3: try {
        var v: Proto_Ext_Ui_HideToastRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .hideToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .hideToast(v)
        }
      }()
      case 4: try {
        var v: Proto_Ext_Ui_UpdateToastRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .updateToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .updateToast(v)
        }
      }()
      case 5: try {
        var v: Proto_Ext_Ui_PushViewRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pushView(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pushView(v)
        }
      }()
      case 6: try {
        var v: Proto_Ext_Ui_PopViewRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .popView(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .popView(v)
        }
      }()
      case 7: try {
        var v: Proto_Ext_Ui_ClearSearchBarRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearSearch_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearSearch_p(v)
        }
      }()
      case 8: try {
        var v: Proto_Ext_Ui_CloseMainWindowRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .closeMainWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .closeMainWindow(v)
        }
      }()
      case 9: try {
        var v: Proto_Ext_Ui_ShowHudRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .showHud(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .showHud(v)
        }
      }()
      case 10: try {
        var v: Proto_Ext_Ui_SetSearchTextRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setSearchText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setSearchText(v)
        }
      }()
      case 11: try {
        var v: Proto_Ext_Ui_ConfirmAlertRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .confirmAlert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .confirmAlert(v)
        }
      }()
      case 12: try {
        var v: Proto_Ext_Ui_GetSelectedTextRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getSelectedText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getSelectedText(v)
        }
      }()
      case 13: try {
        var v: Proto_Ext_Ui_PopToRootRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .popToRoot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .popToRoot(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .render?: try {
      guard case .render(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .showToast?: try {
      guard case .showToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hideToast?: try {
      guard case .hideToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .updateToast?: try {
      guard case .updateToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .pushView?: try {
      guard case .pushView(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .popView?: try {
      guard case .popView(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .clearSearch_p?: try {
      guard case .clearSearch_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .closeMainWindow?: try {
      guard case .closeMainWindow(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .showHud?: try {
      guard case .showHud(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .setSearchText?: try {
      guard case .setSearchText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .confirmAlert?: try {
      guard case .confirmAlert(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .getSelectedText?: try {
      guard case .getSelectedText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .popToRoot?: try {
      guard case .popToRoot(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_Request, rhs: Proto_Ext_Ui_Request) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}render\0\u{3}show_toast\0\u{3}hide_toast\0\u{3}update_toast\0\u{3}push_view\0\u{3}pop_view\0\u{3}clear_search\0\u{3}close_main_window\0\u{3}show_hud\0\u{3}set_search_text\0\u{3}confirm_alert\0\u{3}get_selected_text\0\u{3}pop_to_root\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .render(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .render(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .showToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .showToast(v)
        }
      }()
      case 3: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .hideToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .hideToast(v)
        }
      }()
      case 4: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .updateToast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .updateToast(v)
        }
      }()
      case 5: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pushView(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pushView(v)
        }
      }()
      case 6: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .popView(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .popView(v)
        }
      }()
      case 7: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clearSearch_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clearSearch_p(v)
        }
      }()
      case 8: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .closeMainWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .closeMainWindow(v)
        }
      }()
      case 9: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .showHud(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .showHud(v)
        }
      }()
      case 10: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setSearchText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setSearchText(v)
        }
      }()
      case 11: try {
        var v: Proto_Ext_Ui_ConfirmAlertResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .confirmAlert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .confirmAlert(v)
        }
      }()
      case 12: try {
        var v: Proto_Ext_Ui_GetSelectedTextResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getSelectedText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getSelectedText(v)
        }
      }()
      case 13: try {
        var v: Proto_Ext_Common_AckResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .popToRoot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .popToRoot(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .render?: try {
      guard case .render(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .showToast?: try {
      guard case .showToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hideToast?: try {
      guard case .hideToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .updateToast?: try {
      guard case .updateToast(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .pushView?: try {
      guard case .pushView(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .popView?: try {
      guard case .popView(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .clearSearch_p?: try {
      guard case .clearSearch_p(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .closeMainWindow?: try {
      guard case .closeMainWindow(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .showHud?: try {
      guard case .showHud(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .setSearchText?: try {
      guard case .setSearchText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .confirmAlert?: try {
      guard case .confirmAlert(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .getSelectedText?: try {
      guard case .getSelectedText(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .popToRoot?: try {
      guard case .popToRoot(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_Response, rhs: Proto_Ext_Ui_Response) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_RenderNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenderNode"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}has_dirty_child\0\u{3}has_dirty_props\0\u{1}props\0\u{1}children\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasDirtyChild_p) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasDirtyProps_p) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.props) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.hasDirtyChild_p != false {
      try visitor.visitSingularBoolField(value: self.hasDirtyChild_p, fieldNumber: 2)
    }
    if self.hasDirtyProps_p != false {
      try visitor.visitSingularBoolField(value: self.hasDirtyProps_p, fieldNumber: 3)
    }
    if !self.props.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.props, fieldNumber: 4)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_RenderNode, rhs: Proto_Ext_Ui_RenderNode) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.hasDirtyChild_p != rhs.hasDirtyChild_p {return false}
    if lhs.hasDirtyProps_p != rhs.hasDirtyProps_p {return false}
    if lhs.props != rhs.props {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ThemedImageSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThemedImageSource"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}light\0\u{1}dark\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.light) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.light.isEmpty {
      try visitor.visitSingularStringField(value: self.light, fieldNumber: 1)
    }
    if !self.dark.isEmpty {
      try visitor.visitSingularStringField(value: self.dark, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ThemedImageSource, rhs: Proto_Ext_Ui_ThemedImageSource) -> Bool {
    if lhs.light != rhs.light {return false}
    if lhs.dark != rhs.dark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ImageSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageSource"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}raw\0\u{1}themed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .raw(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Ui_ThemedImageSource?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .themed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .themed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .raw?: try {
      guard case .raw(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .themed?: try {
      guard case .themed(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ImageSource, rhs: Proto_Ext_Ui_ImageSource) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_DynamicColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicColor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}light\0\u{1}dark\0\u{3}adjust_contrast\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.light) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dark) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._adjustContrast) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.light.isEmpty {
      try visitor.visitSingularStringField(value: self.light, fieldNumber: 1)
    }
    if !self.dark.isEmpty {
      try visitor.visitSingularStringField(value: self.dark, fieldNumber: 2)
    }
    try { if let v = self._adjustContrast {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_DynamicColor, rhs: Proto_Ext_Ui_DynamicColor) -> Bool {
    if lhs.light != rhs.light {return false}
    if lhs.dark != rhs.dark {return false}
    if lhs._adjustContrast != rhs._adjustContrast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_ColorLike: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColorLike"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}raw\0\u{1}dynamic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .raw(v)
        }
      }()
      case 2: try {
        var v: Proto_Ext_Ui_DynamicColor?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dynamic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dynamic(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .raw?: try {
      guard case .raw(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .dynamic?: try {
      guard case .dynamic(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_ColorLike, rhs: Proto_Ext_Ui_ColorLike) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Ext_Ui_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}fallback\0\u{1}mask\0\u{3}tint_color\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fallback) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._mask) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tintColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fallback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mask {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tintColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Ext_Ui_Image, rhs: Proto_Ext_Ui_Image) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._fallback != rhs._fallback {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs._tintColor != rhs._tintColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
